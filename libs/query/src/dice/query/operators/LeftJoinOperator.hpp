#ifndef QUERY_LEFTJOINOPERATOR_HPP
#define QUERY_LEFTJOINOPERATOR_HPP

#include "CardinalityEstimation.hpp"
#include "Operator_predeclare.hpp"

#include <dice/hypertrie/HashJoin.hpp>

#include <boost/container/flat_set.hpp>

namespace dice::query::operators {
	template<typename value_type, hypertrie::HypertrieTrait_bool_valued htt_t, hypertrie::ByteAllocator allocator_type>
	struct LeftJoinOperator {
		static constexpr bool bool_valued = std::is_same_v<value_type, bool>;

	private:
		/**
		 * @brief Finds the empty operands and prunes the provided OperandDependencyGraph.
		 * @param odg: OperandDependencyGraph to be pruned
		 * @param operands: Vector of hypertries
		 * @return a pair consisting of the pruned graph and its corresponding operands
		 */
		inline static std::pair<OperandDependencyGraph *, std::vector<hypertrie::const_Hypertrie<htt_t, allocator_type>>>
		prune_empty(OperandDependencyGraph &odg,
					std::vector<hypertrie::const_Hypertrie<htt_t, allocator_type>> const &operands) {
			std::vector<hypertrie::internal::pos_type> empty_sub_ops{};
			std::vector<hypertrie::const_Hypertrie<htt_t, allocator_type>> pruned_operands{};
			for (size_t pos = 0; pos < operands.size(); pos++) {
				if (operands[pos].empty())
					empty_sub_ops.push_back(pos);
			}
			OperandDependencyGraph *pruned_odg = &odg.prune_graph(empty_sub_ops);
			for (auto pos : pruned_odg->operands_original_positions()) {
				// do not pass scalars (all scalars at this point are true)
				// scalars that are true are generated by the optional version of HashJoin
				if (operands[pos].depth() > 0)
					pruned_operands.push_back(operands[pos]);
			}
			return std::make_pair(pruned_odg, pruned_operands);
		}

		/**
		 * @brief Checks whether the operator can yield a solution even if the sub_operator does not yield one.
		 * @param odg: OperandDependencyGraph
		 * @return whether all non-optional operands of odg are resolved
		 */
		inline static bool non_opt_evaluated(OperandDependencyGraph &odg) {
			boost::container::flat_set<char> vars{};
			for (auto pos : odg.isc_operands()) {
				auto const &op_labels = odg.operand_var_ids(pos);
				vars.insert(op_labels.begin(), op_labels.end());
				if (vars.size() > 1)
					return false;
			}
			return true;
		}

	public:
		inline static std::generator<Entry<value_type, htt_t> const &>
		generator(OperandDependencyGraph &odg,
				  std::vector<hypertrie::const_Hypertrie<htt_t, allocator_type>> const &operands,
				  Query<htt_t, allocator_type> const &query,
				  Entry<value_type, htt_t> &entry_arg) {
			clear_used_entry_poss<value_type, htt_t, allocator_type>(entry_arg, odg, query);
			auto eval_var = CardinalityEstimation<htt_t, allocator_type, true>::getMinCardLabel(odg, operands, query);
			bool is_proj_var = query.contains_proj_var(eval_var);
			uint8_t proj_var_pos;
			if (is_proj_var)
				proj_var_pos = query.projected_var_position(eval_var);
			const bool evaluated = non_opt_evaluated(odg);
			for (auto &[current_key_part, sub_operands] : hypertrie::HashJoin<htt_t, allocator_type, true>{operands,
																										   odg.var_ids_positions_in_operands(eval_var),
																										   odg.isc_operands()}) {
				query.check_time_out();
				if (is_proj_var)
					entry_arg[proj_var_pos] = current_key_part;
				// prune empty operands
				auto [pruned_odg, pruned_sub_operands] = prune_empty(odg, sub_operands);
				auto &sub_odg = pruned_odg->remove_var_id(eval_var);
				if (query.all_result_done(sub_odg)) {
					auto &entry = get_sub_operator<value_type, htt_t, allocator_type, true>(sub_odg, pruned_sub_operands, query, entry_arg);
					if (entry.value())
						co_yield entry;
					// yield the current entry if the sub_operator did not yield a solution, and it is allowed
					else if (evaluated) {
						entry_arg.value(1);
						co_yield entry_arg;
					}
				} else {
					bool at_least_one_entry = false;
					for (auto const &entry : get_sub_operator<value_type, htt_t, allocator_type, false>(sub_odg, pruned_sub_operands, query, entry_arg)) {
						co_yield entry;
						at_least_one_entry = true;// the sub_operator yielded at least one solution
					}
					// yield the current entry if the sub_operator did not yield a solution, and it is allowed
					if (not at_least_one_entry and evaluated) {
						entry_arg.value(1);
						co_yield entry_arg;
					}
				}
				// reset entry
				clear_used_entry_poss<value_type, htt_t, allocator_type>(entry_arg, odg, query);
				entry_arg.value(1);
			}
		}

		inline static Entry<value_type, htt_t> const &
		single_result(OperandDependencyGraph &odg,
					  std::vector<hypertrie::const_Hypertrie<htt_t, allocator_type>> const &operands,
					  Query<htt_t, allocator_type> const &query,
					  Entry<value_type, htt_t> &entry_arg) {
			clear_used_entry_poss<value_type, htt_t, allocator_type>(entry_arg, odg, query);
			char eval_var = odg.operand_var_ids(odg.isc_operands().front()).front();// need to optimize
			const bool evaluated = non_opt_evaluated(odg);
			[[maybe_unused]] value_type value = 0;
			for (auto &[current_key_part, sub_operands] : hypertrie::HashJoin<htt_t, allocator_type, true>{operands,
																										   odg.var_ids_positions_in_operands(eval_var),
																										   odg.isc_operands()}) {
				query.check_time_out();
				auto [pruned_odg, pruned_sub_operands] = prune_empty(odg, sub_operands);
				auto &sub_odg = pruned_odg->remove_var_id(eval_var);
				const auto &entry = get_sub_operator<value_type, htt_t, allocator_type, true>(sub_odg, sub_operands, query, entry_arg);
				if constexpr (bool_valued) {
					return entry;
				} else {
					value += entry.value();
				}
			}
			// yield the current entry if the sub_operator did not yield a solution, and it is allowed
			if (not entry_arg.value() and evaluated)
				value = 1;
			entry_arg.value(value);
			return entry_arg;
		}
	};
}// namespace dice::query::operators
#endif//QUERY_LEFTJOINOPERATOR_HPP
