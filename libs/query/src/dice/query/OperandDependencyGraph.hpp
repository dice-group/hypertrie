#ifndef QUERY_OPERANDDEPENDENCYGRAPH_HPP
#define QUERY_OPERANDDEPENDENCYGRAPH_HPP

#include <utility>
#include <vector>

#include <boost/container/flat_map.hpp>
#include <boost/container/flat_set.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/connected_components.hpp>
#include <boost/graph/filtered_graph.hpp>
#include <boost/graph/graph_traits.hpp>
#include <boost/graph/strong_components.hpp>
#include <boost/graph/subgraph.hpp>

#include "Commons.hpp"

namespace dice::query {

	class OperandDependencyGraph {

	private:
		using VariableID = char;
		using VertexSetHash = size_t;
		/* requirements for boost graph */
		struct VertexProperties_t {
			using kind = boost::vertex_property_tag;
		};
		struct EdgeProperties_t {
			using kind = boost::edge_property_tag;
		};
		struct VertexProperties {
			std::vector<VariableID> var_ids;
		};
		struct EdgeProperties {
			VariableID var_id = '\0';
			bool is_opt = false;
		};
		using vertex_prop = boost::property<VertexProperties_t,
											VertexProperties>;
		using edge_prop = boost::property<boost::edge_index_t,
										  std::size_t,
										  boost::property<EdgeProperties_t,
														  EdgeProperties>>;
		using DirectedLabelledGraph = boost::subgraph<boost::adjacency_list<boost::vecS,
																			boost::vecS,
																			boost::directedS,
																			vertex_prop,
																			edge_prop>>;
		using LabelledGraph = boost::adjacency_list<boost::vecS,
													boost::vecS,
													boost::undirectedS,
													vertex_prop,
													edge_prop>;

		using Edge = DirectedLabelledGraph::edge_descriptor;
		using Vertex = query::pos_type;

		/* fields */
		// the unique identifier of the dependency graph
		size_t identifier_;
		// the dependency graph
		DirectedLabelledGraph odg_;
		// the components of a cartesian operation
		std::vector<OperandDependencyGraph> cartesian_components_;
		// the components of a union operation
		std::vector<OperandDependencyGraph> union_components_;
		// the non-optional parts of the query (the vertices that are found in the independent strong component)
		std::vector<Vertex> isc_operands_;
		// the positions of the operands in the parent graph
		std::vector<Vertex> original_positions_;
		// the graphs generated by pruning a specific set of vertices
		std::map<VertexSetHash, OperandDependencyGraph> pruned_subgraphs_;// TODO: use a faster node map implementation
		// the graph generated by removing a specific variable id
		std::map<VariableID, OperandDependencyGraph> subgraphs_;// TODO: use a faster node map implementation
		// the ids of all variables
		boost::container::flat_set<VariableID> operands_var_ids_set_;
		// the ids of the variables appearing in the independent strong component
		boost::container::flat_set<VariableID> non_optional_var_ids_set_;
		// the ids of the variables appearing only once
		boost::container::flat_set<VariableID> lonely_var_ids_;
		// the positions of a particular variable id in each operand
		boost::container::flat_map<VariableID, std::vector<std::vector<Vertex>>> var_ids_positions_in_operands_;
		// the operands that contain a particular variable id
		boost::container::flat_map<VariableID, std::vector<Vertex>> operands_with_var_id_;
		// the operands of the ISC that contain a particular variable id
		boost::container::flat_map<VariableID, std::vector<Vertex>> isc_operands_with_var_id_;
		// used in cartesian joins; denotes if the cartesian is between optional components of the query
		bool opt_cartesian_ = false;

	public:
		// the dependency graph is assigned a unique size_t identifier
		// when a dependency graph is copied, its identifier is copied as well
		OperandDependencyGraph() {
			static std::atomic<size_t> next_id {0};
			identifier_ = next_id++;
		}

		/* graph manipulation */

		/**
		 * @brief Creates a new vertex/operand in the operand dependency graph
		 * @param var_ids: The ids of the variables corresponding to the operand
		 * @return the descriptor(position) of the vertex(operand)
		 */
		inline Vertex add_operand(std::vector<VariableID> var_ids) {
			auto desc = boost::add_vertex(odg_);
			auto v_properties = boost::get(VertexProperties_t(), odg_);
			v_properties[desc].var_ids = std::move(var_ids);
			return desc;
		}

		/**
		 * @brief Creates an edge between two vertices/operands.
		 * The edge is not optional, i.e., it will be used to prune operands.
		 * @param source: The descriptor(position) of the source vertex(operand)
		 * @param target: The descriptor(position) of the target vertex(operand)
		 * @param var_id: The id of the variable that is shared between the two operands. It used to label the edge.
		 */
		inline void add_dependency(Vertex source, Vertex target, VariableID var_id = '\0') {
			auto desc = boost::add_edge(source, target, odg_);
			auto e_properties = boost::get(EdgeProperties_t(), odg_);
			e_properties[desc.first].var_id = var_id;
		}

		/**
		 * @brief Creates an edge between two vertices/operands.
		 * The edge is optional, i.e., it will <b>not</b> be used to prune operands.
		 * @param source: The descriptor(position) of the source vertex(operand)
		 * @param target: The descriptor(position) of the target vertex(operand)
		 * @param var_id: The id of the variable that is shared between the two operands. It used to label the edge.
		 */
		inline void add_connection(Vertex source, Vertex target, VariableID var_id = '\0') {
			auto desc = boost::add_edge(source, target, odg_);
			auto &new_e_properties = boost::get(EdgeProperties_t(), odg_)[desc.first];
			new_e_properties.var_id = var_id;
			new_e_properties.is_opt = true;
		}

		/**
		 * @brief Creates a new graph that does not contain the provided vertices.
		 * @param vertices: The vertices that will not be included in the new graph
		 * @return An OperandDependencyGraph
		 */
		inline OperandDependencyGraph remove_vertices(std::vector<Vertex> const &vertices) {
			OperandDependencyGraph new_odg{};
			new_odg.odg_ = odg_.create_subgraph();
			auto v_iters = boost::vertices(odg_);
			for (auto v_iter = v_iters.first; v_iter != v_iters.second; v_iter++) {
				if (std::find(vertices.begin(), vertices.end(), *v_iter) == vertices.end())
					boost::add_vertex(odg_.local_to_global(*v_iter), new_odg.odg_);
			}
			return new_odg;
		}

		/**
		 * @brief Creates a new graph which does not include the provided variable id.
		 * The provided variable id is removed from edge and vertex properties.
		 * Vertices that do not contain any variable id after the provided variable id
		 * is removed are not included in the new graph.
		 * @param var_id: The variable id to be removed
		 * @return An OperandDependencyGraph
		 */
		[[nodiscard]] inline OperandDependencyGraph &remove_var_id(VariableID var_id) {
			/*
			 * As we do not want to remove the variable ids from the current (parent) graph,
			 * we need to copy the current graph to a new graph first. Since the vertices whose
			 * list of variables ids contains only the provided variable id will not be included
			 * in the new graph, they won't be copied to the new graph
			 */
			if (subgraphs_.contains(var_id))
				return subgraphs_[var_id];
			auto &new_odg = subgraphs_[var_id];
			auto temp_graph = odg_.create_subgraph();// will contain only the vertices that will be included in the new graph
			auto const &v_properties = boost::get(VertexProperties_t(), odg_);
			auto v_iters = boost::vertices(odg_);
			for (auto v_iter = v_iters.first; v_iter != v_iters.second; v_iter++) {
				if (std::any_of(v_properties[*v_iter].var_ids.begin(), v_properties[*v_iter].var_ids.end(),
								[&](VariableID v_id) { return v_id != var_id; }))
					// need to use global identifier in order to not introduce a new vertex
					boost::add_vertex(odg_.local_to_global(*v_iter), temp_graph);
			}
			// keep original positions (i.e., the positions of the operands in the current graph)
			v_iters = boost::vertices(temp_graph);
			std::vector<Vertex> orig_poss{};
			for (auto v_iter = v_iters.first; v_iter != v_iters.second; v_iter++) {
				orig_poss.push_back(temp_graph.local_to_global(*v_iter));
			}
			// create the new graph
			boost::copy_graph(temp_graph, new_odg.odg_);
			// remove the provided variable id from vertex properties
			auto const &v_properties_new = boost::get(VertexProperties_t(), new_odg.odg_);
			v_iters = boost::vertices(new_odg.odg_);
			for (auto v_iter = v_iters.first; v_iter != v_iters.second; v_iter++) {
				std::erase_if(v_properties_new[*v_iter].var_ids, [&](VariableID v_id) { return v_id == var_id; });
			}
			// remove the provided variable id from edge properties
			auto const &e_properties_new = boost::get(EdgeProperties_t(), new_odg.odg_);
			auto e_iters = boost::edges(new_odg.odg_);
			for (auto e_iter = e_iters.first; e_iter != e_iters.second; e_iter++) {
				if (auto &v_id = e_properties_new[*e_iter].var_id; v_id == var_id)
					v_id = '\0';
			}
			new_odg.original_positions_ = std::move(orig_poss);
			return new_odg;
		}

		/**
		 * @brief This method removes the provided empty operands along with the operands that transitively depend on them
		 * (i.e., the operands that are reachable via edges that are not optional).
		 * @param empty_operands: The positions of the operands that are empty
		 * @return An OperandDependencyGraph
		 */
		inline OperandDependencyGraph &prune_graph(std::vector<Vertex> const &empty_operands) {
			VertexSetHash vertex_set_hash = dice::hash::dice_hash_templates<dice::hash::Policies::wyhash>::dice_hash(empty_operands);
			// check first if the same set of operands was already provided
			if (pruned_subgraphs_.contains(vertex_set_hash))
				return pruned_subgraphs_[vertex_set_hash];
			auto const &e_properties = boost::get(EdgeProperties_t(), odg_);
			auto &sub_graph = pruned_subgraphs_[vertex_set_hash];
			// create a new graph
			sub_graph.odg_ = odg_.create_subgraph();
			boost::container::flat_set<Vertex> pruned{};
			std::deque<Vertex> to_check{empty_operands.begin(), empty_operands.end()};// contains the vertices that need to be visited
			// traverse the graph to find all vertices(operands) that depend on the operands that were provided
			while (not to_check.empty()) {
				auto operand = to_check.front();
				to_check.pop_front();
				if (pruned.find(operand) != pruned.end())
					continue;
				pruned.insert(operand);
				auto out_edge_iters = boost::out_edges(operand, odg_);
				for (auto out_edge_iter = out_edge_iters.first; out_edge_iter != out_edge_iters.second; out_edge_iter++) {
					if (not e_properties[*out_edge_iter].is_opt)
						to_check.push_back(boost::target(*out_edge_iter, odg_));
				}
			}
			// the new graph will contain only the vertices that should not be pruned
			auto vertex_iters = boost::vertices(odg_);
			for (auto vertex_iter = vertex_iters.first; vertex_iter != vertex_iters.second; vertex_iter++) {
				if (pruned.find(*vertex_iter) == pruned.end())
					// need to use global identifier in order to not introduce a new vertex
					boost::add_vertex(odg_.local_to_global(*vertex_iter), sub_graph.odg_);
			}
			return sub_graph;
		}

		/* graph information */

		[[nodiscard]] inline std::size_t identifier() const noexcept {
			return identifier_;
		}

		[[nodiscard]] inline std::size_t size() const {
			return boost::num_vertices(odg_);
		}

		[[nodiscard]] inline bool optional_cartesian() const noexcept {
			return opt_cartesian_;
		}

		[[nodiscard]] inline std::vector<Vertex> const &operands_original_positions() {
			if (not original_positions_.empty())
				return original_positions_;
			auto vertices_iterators = boost::vertices(odg_);
			if (odg_.m_parent) {
				for (auto vertex_iter = vertices_iterators.first; vertex_iter != vertices_iterators.second; vertex_iter++) {
					auto global_desc = odg_.local_to_global(*vertex_iter);
					// store the identifier/descriptor of the parent, not the global
					original_positions_.push_back(odg_.parent().global_to_local(global_desc));
				}
			} else {
				for (uint8_t i = 0; i < size(); i++) {
					original_positions_.push_back(i);
				}
			}
			return original_positions_;
		}

		[[nodiscard]] inline std::vector<char> const &operand_var_ids(Vertex operand) const {
			auto const &v_properties = boost::get(VertexProperties_t(), odg_);
			return v_properties[operand].var_ids;
		}

		[[nodiscard]] inline boost::container::flat_set<char> const &operands_var_ids_set() {
			if (operands_var_ids_set_.empty()) {
				auto v_properties = boost::get(VertexProperties_t(), odg_);
				auto vertex_iters = boost::vertices(odg_);
				for (auto v_iter = vertex_iters.first; v_iter != vertex_iters.second; v_iter++) {
					operands_var_ids_set_.insert(v_properties[*v_iter].var_ids.begin(),
												 v_properties[*v_iter].var_ids.end());
				}
			}
			return operands_var_ids_set_;
		}

		[[nodiscard]] inline boost::container::flat_set<char> const &non_optional_var_ids_set() {
			if (non_optional_var_ids_set_.empty()) {
				auto v_properties = boost::get(VertexProperties_t(), odg_);
				auto const &isc_ops = isc_operands();
				for (auto const &isc_op : isc_ops) {
					for (auto const &var_id : v_properties[isc_op].var_ids) {
						non_optional_var_ids_set_.insert(var_id);
					}
				}
			}
			return non_optional_var_ids_set_;
		}

		[[nodiscard]] inline std::vector<std::vector<Vertex>> const &var_ids_positions_in_operands(char var_id) {
			auto &var_id_positions = var_ids_positions_in_operands_[var_id];
			if (not var_id_positions.empty())
				return var_id_positions;
			auto v_properties = boost::get(VertexProperties_t(), odg_);
			auto vertex_iters = boost::vertices(odg_);
			for (auto v_iter = vertex_iters.first; v_iter != vertex_iters.second; v_iter++) {
				std::vector<Vertex> op_positions{};
				for (std::size_t pos = 0; pos < v_properties[*v_iter].var_ids.size(); pos++) {
					if (v_properties[*v_iter].var_ids[pos] == var_id)
						op_positions.push_back(pos);
				}
				var_id_positions.push_back(std::move(op_positions));
			}
			return var_id_positions;
		}

		[[nodiscard]] inline std::vector<Vertex> const &operands_with_var_id(char var_id) {
			auto found = operands_with_var_id_.find(var_id);
			if (found != operands_with_var_id_.end()) {
				return found->second;
			}
			auto &operands = operands_with_var_id_[var_id];
			auto v_properties = boost::get(VertexProperties_t(), odg_);
			auto vertex_iters = boost::vertices(odg_);
			for (auto v_iter = vertex_iters.first; v_iter != vertex_iters.second; v_iter++) {
				if (std::find(v_properties[*v_iter].var_ids.begin(), v_properties[*v_iter].var_ids.end(), var_id) !=
					v_properties[*v_iter].var_ids.end())
					operands.push_back(*v_iter);
			}
			return operands;
		}

		[[nodiscard]] inline std::vector<Vertex> const &isc_operands_with_var_id(char var_id) {
			auto found = isc_operands_with_var_id_.find(var_id);
			if (found != isc_operands_with_var_id_.end()) {
				return found->second;
			}
			auto &operands = isc_operands_with_var_id_[var_id];
			auto const &isc_ops = isc_operands();
			auto v_properties = boost::get(VertexProperties_t(), odg_);
			auto vertex_iters = boost::vertices(odg_);
			for (auto v_iter = vertex_iters.first; v_iter != vertex_iters.second; v_iter++) {
				if (std::find(isc_ops.begin(), isc_ops.end(), *v_iter) == isc_ops.end())
					continue;
				if (std::find(v_properties[*v_iter].var_ids.begin(), v_properties[*v_iter].var_ids.end(), var_id) !=
					v_properties[*v_iter].var_ids.end())
					operands.push_back(*v_iter);
			}
			return operands;
		}

		[[nodiscard]] inline boost::container::flat_set<char> const &lonely_var_ids() {
			if (lonely_var_ids_.empty()) {
				std::set<char> visited{};
				auto v_properties = boost::get(VertexProperties_t(), odg_);
				auto vertex_iters = boost::vertices(odg_);
				for (auto v_iter = vertex_iters.first; v_iter != vertex_iters.second; v_iter++) {
					for (auto const &var_id : v_properties[*v_iter].var_ids) {
						if (lonely_var_ids_.contains(var_id)) {
							lonely_var_ids_.erase(var_id);
						} else {
							if (not visited.contains(var_id)) {
								lonely_var_ids_.insert(var_id);
								visited.insert(var_id);
							}
						}
					}
				}
			}
			return lonely_var_ids_;
		}
		/* graph algorithms */

		/**
		 * @brief Generates the union components of the query represented by the graph.
		 * The query contains union components if the graph is disconnected.
		 * The connected components of the undirected version of the graph are the union components.
		 * The union components are computed only once.
		 * @return a vector of OperandDependencyGraph
		 */
		inline std::vector<OperandDependencyGraph> &union_components() {
			if (not union_components_.empty()) {
				return union_components_;
			}
			// create an undirected copy of the graph
			LabelledGraph undirected_graph;
			boost::copy_graph(odg_, undirected_graph);
			// compute connected components using the undirected version of the graph
			std::vector<Vertex> components(boost::num_vertices(undirected_graph));
			auto num_components = boost::connected_components(undirected_graph, components.data());
			// single connected component -> return the current graph
			if (num_components == 1)
				union_components_.push_back(*this);
			// multiple connected components -> one subgraph per connected component
			else
				sub_odg(num_components, components, union_components_);
			return union_components_;
		}

		/**
		 * @brief Generates the cartesian components of the query represented by the graph.
		 * The process for generating cartesian components is twofold.
		 * First the unlabeled edges of the graph are filtered out.
		 * Then the connected components of the filtered graph are computed.
		 * The connected components are the cartesian components of the original graph.
		 * The cartesian components are computed only once.
		 * @return a vector of OperandDependencyGraph
		 */
		inline std::vector<OperandDependencyGraph> &cartesian_components() {
			if (not cartesian_components_.empty())
				return cartesian_components_;
			auto const &e_properties = boost::get(EdgeProperties_t(), odg_);
			auto const &isc_ops = isc_operands();
			// use filtered graph to remove unlabelled edges -- only the unlabeled edges in the ISC are removed
			// if any of the edge are optional, the cartesian is between different optional parts of the query
			using FilteredGraph = boost::filtered_graph<DirectedLabelledGraph,
														std::function<bool(Edge)>, boost::keep_all>;
			auto edge_filter = [&](Edge e_desc) -> bool {
				if (std::find(isc_ops.begin(), isc_ops.end(), e_desc.m_target) == isc_ops.end())
					return true;
				if (e_properties[e_desc].is_opt)
					this->opt_cartesian_ = true;// TODO: find better solution
				return e_properties[e_desc].var_id;
			};
			FilteredGraph filtered_graph = FilteredGraph(odg_, edge_filter, boost::keep_all{});
			// the weakly connected components of the filtered graph represent the cartesian components
			// use the undirected graph of the filtered graph to compute the connected components
			LabelledGraph undirected_graph;
			boost::copy_graph(filtered_graph, undirected_graph);
			// make sure that unions will be preserved by adding temporary edges
			for (auto first : isc_ops) {
				for (auto second : isc_ops) {
					if (not boost::edge(first, second, odg_).second)
						boost::add_edge(first, second, undirected_graph);
				}
			}
			std::vector<Vertex> components(boost::num_vertices(undirected_graph));
			auto num_components = boost::connected_components(undirected_graph, components.data());
			sub_odg(num_components, components, cartesian_components_);
			return cartesian_components_;
		}

		/**
		 * @brief Generates the nodes of the graph that belong to the independent strong component (ISC) of the graph.
		 * The ISC of the graph is the root node of the DAG connecting the strong components of the graph.
		 * The nodes of the ISC is generated by finding the strong components of the graph.
		 * The nodes of the ISC are generated only once.
		 * @return a vector of identifiers/positions (uint8_t)
		 */
		inline std::vector<Vertex> &isc_operands() {
			if (not isc_operands_.empty())
				return isc_operands_;
			// compute the strong components -- https://www.boost.org/doc/libs/1_78_0/libs/graph/example/strong_components.cpp
			std::vector<Vertex> components(boost::num_vertices(odg_));
			std::vector<Vertex> discover_time(boost::num_vertices(odg_));
			std::vector<boost::default_color_type> color(num_vertices(odg_));
			std::vector<Vertex> root(num_vertices(odg_));
			auto num_components = boost::strong_components(odg_,
														   make_iterator_property_map(components.begin(), get(boost::vertex_index, odg_)),
														   root_map(make_iterator_property_map(root.begin(), get(boost::vertex_index, odg_)))
																   .color_map(
																		   make_iterator_property_map(color.begin(), get(boost::vertex_index, odg_)))
																   .discover_time_map(make_iterator_property_map(
																		   discover_time.begin(), get(boost::vertex_index, odg_))));
			// only one strong component -> The ISC is the current graph
			if (num_components == 1) {
				isc_operands_.resize(boost::num_vertices(odg_));
				std::iota(isc_operands_.begin(), isc_operands_.end(), 0);
			} else {
				// multiple strong components -> The nodes of ISC do not have incoming edges from nodes outside the ISC
				std::set<Vertex> candidates;
				for (auto comp = 0; comp < num_components; comp++)
					candidates.insert(comp);
				auto vertex_iters = boost::vertices(odg_);
				for (auto iter = vertex_iters.first; iter != vertex_iters.second; iter++) {
					auto adj_v_iters = boost::adjacent_vertices(*iter, odg_);
					for (auto adj_iter = adj_v_iters.first; adj_iter != adj_v_iters.second; adj_iter++) {
						if (components[*adj_iter] != components[*iter])
							candidates.erase(components[*adj_iter]);
					}
				}
				assert(candidates.size() == 1);
				for (auto iter = vertex_iters.first; iter != vertex_iters.second; iter++) {
					if (candidates.contains(components[*iter]))
						isc_operands_.push_back(*iter);
				}
			}
			return isc_operands_;
		}

	private:
		/**
		 * @brief Creates an operand dependency graph for each connected component.
		 * @param num_components: The number of components
		 * @param components: The component to which each node belongs to
		 * @param connected_components: Contains the generated dependency graphs
		 */
		inline void sub_odg(std::size_t num_components,
							const std::vector<Vertex> &components,
							std::vector<OperandDependencyGraph> &connected_components) {
			connected_components.resize(num_components);
			for (std::size_t component = 0; component < num_components; component++) {
				connected_components[component].odg_ = odg_.create_subgraph();
			}
			for (Vertex vertex = 0; vertex < components.size(); vertex++) {
				// need to use global identifier in order to not introduce a new vertex
				boost::add_vertex(odg_.local_to_global(vertex), connected_components[components[vertex]].odg_);
			}
		}
	};

}// namespace dice::query

#endif//QUERY_OPERANDDEPENDENCYGRAPH_HPP
