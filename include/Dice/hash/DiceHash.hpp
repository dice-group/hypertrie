#ifndef HYPERTRIE_DICEHASH_HPP
#define HYPERTRIE_DICEHASH_HPP

/** @file Home of the DiceHash implementation.
 * To speed up tests of the Hypertrie and Tentris we needed to be able to serialize a Hypertrie and save it.
 * However the last hash function was not "stable", i.e. it chose two different random seeds, so the results differed.
 * Because of that (and to not worry about versioning problems) this hash function was created.
 */

#include <cstring>
#include <functional>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <string_view>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <utility>

#include "Dice/hash/xxhash.hpp"
#include "Dice/hash/Container_trait.h"

/** Home of the DiceHash and its helper functions.
 */
namespace Dice::hash {

    /** Seed for the hash function.
     * constexpr because the resulting hash needs to be stable.
     */
	inline static constexpr std::size_t seed = std::size_t(0xA24BAED4963EE407UL);

	/** Helper function for tuple hashing.
	 * It simply hashes every parameter and then combines them.
	 * CAUTION: The order of the parameters CAN make a difference!
	 * @tparam Ts Parameter pack. The hash function must be defined for every type used.
	 * @param values The values to hash and combine.
	 * @return Hash value.
	 */
	template<typename... Ts>
	std::size_t hash_and_combine(Ts &&...values);

	/** Home of the specific implementation of the hash for basic types.
	 */
	namespace detail {
	    /** Size of a std::size_t.
	     */
		inline static constexpr std::size_t size_t_bits = 8 * sizeof(std::size_t);

		/** Hash values saved in continues memory.
		 * An example would be a c-string or vector.data.
		 * @param ptr Pointer to the beginning of the memory.
		 * @param len The number of bytes stored in memory.
		 * @return Hash value.
		 */
		inline std::size_t hash_bytes(void const *ptr, std::size_t len) noexcept {
			return xxh::xxhash3<size_t_bits>(ptr, len, seed);
		}

		/** Wrapper for fundamental types.
		 * Calls hash_bytes for every fundamental type (including pointers to fundamentals).
		 * @tparam T Fundamental type or pointer to a fundamental (using constrains).
		 * @param x The value to hash.
		 * @return Hash value.
		 */
		template<typename T>
		requires std::is_fundamental_v<std::decay_t<T>> or std::is_pointer_v<std::decay_t<T>>
		inline std::size_t hash_primitive(T x) noexcept {
			return xxh::xxhash3<size_t_bits>(&x, sizeof(T), seed);
		}

		/** Helper function for hashing tuples.
		 * It is a wrapper for hash_and_combine.
		 * This function can be called with the help of std::make_index_sequence.
		 * @tparam TupleArgs The types used in the tuple.
		 * @tparam ids Generated by std::make_index_sequence. Needed for indexing the tuple values.
		 * @param tuple The tuple to hash.
		 * @return Hash value.
		 */
		template<typename... TupleArgs, std::size_t... ids>
		std::size_t hash_tuple(std::tuple<TupleArgs...> const &tuple, std::index_sequence<ids...> const &) {
			return ::Dice::hash::hash_and_combine(std::get<ids>(tuple)...);
		}
	}// namespace detail


	/** Combines two hashes to a new hash.
	 * It is commutative.
     * It is used in the (un-)ordered container functions. However this WILL be replaced in the future.
     * @param a First hash.
     * @param b Second hash.
     * @return Combination of a and b.
     */
	inline std::size_t dice_hash_invertible_combine(std::size_t a, std::size_t b) {
		return a xor b;
	}


	/** Calculates the Hash over an ordered container.
     * An example would be a vector, a map, an array or a list.
     * Needs a ForwardIterator in the Container-type, and an member type "value_type".
     * @tparam Container The container type (vector, map, list, etc).
     * @param container The container to calculate the hash value of.
     * @return The combined hash of all Values inside of the container.
     */
	template<typename Container>
	std::size_t dice_hash_ordered_container(Container const &container);

	/** Calculates the Hash over an unordered container.
     * An example would be a unordered_map or an unordered_set.
     * CAUTION: This function is not evaluated yet! It's performance it not tested.
     * Also it is simply an commutative operation on the data inside, because a specific layout cannot be assumed.
     * Needs a ForwardIterator in the Container-type, and an member type "value_type".
     * @tparam Container The container type (unordered_map/set etc).
     * @param container The container to calculate the hash value of.
     * @return The combined hash of all Values inside of the container.
     */
	template<typename Container>
	std::size_t dice_hash_unordered_container(Container const &container);

	/** Default implementation of the dice_hash function.
	 * It will simply throw an exception if used. For every type there should be an specific overload.
	 * This should be replaced by a static_assert, however in the current code base it IS used at some point.
	 * @tparam T Type of the value to hash.
	 * @return Nothing. It WILL throw every time.
	 */
	template<typename T>
	std::size_t dice_hash(T const &) noexcept {
		throw std::logic_error("Hash must be declared explicitly.");
	}

	/** Implementation for fundamentals and pointer to fundamentals.
	 * It simply uses hash_primitive.
	 * CAUTION: std::is_pointer_v is a misuse! We do not test if it is a pointer to a fundamental!
	 * @tparam T Type (fundamental or pointer to fundamental).
	 * @param fundamental Value to hash.
	 * @return Hash value.
	 */
	template<typename T>
	requires std::is_fundamental_v<T> or std::is_pointer_v<T>
	std::size_t dice_hash(T const &fundamental) noexcept {
		return detail::hash_primitive(fundamental);
	}

	/** Implementation for string types.
	 * It simply uses hash_bytes.
	 * @tparam CharT A char type. See the definition of std::string for more information.
	 * @param str The string to hash.
	 * @return Hash value.
	 */
	template<typename CharT>
	std::size_t dice_hash(std::basic_string<CharT> const &str) noexcept {
		return detail::hash_bytes(str.data(), sizeof(CharT) * str.size());
	}

	/** Implementation for string view.
	 * It simply uses hash_bytes on the string views data.
	 * @tparam CharT A char type. See the definition of std::string for more information.
	 * @param sv The string view to hash.
	 * @return Hash value.
	 */
	template<typename CharT>
	std::size_t dice_hash(std::basic_string_view<CharT> const &sv) noexcept {
		return detail::hash_bytes(sv.data(), sizeof(CharT) * sv.size());
	}

	/** Implementation for unique pointers.
	 * It simply uses the dice_hash itself for its value.
	 * @tparam T Type the pointer references to.
	 * @param ptr The pointer itself.
	 * @return Hash value.
	 */
	template<typename T>
	std::size_t dice_hash(std::unique_ptr<T> const &ptr) noexcept {
		return dice_hash(ptr.get());
	}

    /** Implementation for shared pointers.
     * It simply uses the dice_hash itself for its value.
     * @tparam T Type the pointer references to.
     * @param ptr The pointer itself.
     * @return Hash value.
     */
	template<typename T>
	std::size_t dice_hash(std::shared_ptr<T> const &ptr) noexcept {
		return dice_hash(ptr.get());
	}

	/** Implementation for std arrays.
	 * It will use different implementations if the type is fundamental or not.
	 * @tparam T The type of the values.
	 * @tparam N The number of values.
	 * @param arr The array itself.
	 * @return Hash value.
	 */
	template<typename T, std::size_t N>
	std::size_t dice_hash(std::array<T, N> const &arr) noexcept {
		if constexpr (std::is_fundamental_v<T>) {
			return detail::hash_bytes(arr.data(), sizeof(T) * N);
		} else {
			return dice_hash_ordered_container(arr);
		}
	}

	/** Implementation for vectors.
	 * It will use different implementations for fundamental and non-fundamental types.
	 * @tparam T The type of the values.
	 * @param vec The vector itself.
	 * @return Hash value.
	 */
	template<typename T>
	std::size_t dice_hash(std::vector<T> const &vec) noexcept {
		if constexpr (std::is_fundamental_v<T>) {
			static_assert(!std::is_same_v<std::decay_t<T>, bool>,
						  "vector of booleans has a special implementation which results into errors!");
			return detail::hash_bytes(vec.data(), sizeof(T) * vec.size());
		} else {
			return dice_hash_ordered_container(vec);
		}
	}

	/** Implementation for tuples.
	 * Will hash every entry and then combine the hashes.
	 * @tparam TupleArgs The types of the tuple values.
	 * @param tpl The tuple itself.
	 * @return Hash value.
	 */
	template<typename... TupleArgs>
	std::size_t dice_hash(std::tuple<TupleArgs...> const &tpl) noexcept {
		return detail::hash_tuple(tpl, std::make_index_sequence<sizeof...(TupleArgs)>());
	}

	/** Implementation for pairs.
	 * Will hash the entries and then combine them.
	 * @tparam T Type of the first value.
	 * @tparam V Type of the second value.
	 * @param p The pair itself.
	 * @return Hash value.
	 */
	template<typename T, typename V>
	std::size_t dice_hash(std::pair<T, V> const &p) noexcept {
		return hash_and_combine(p.first, p.second);
	}

	/** Implementation for ordered container.
	 * It uses a custom type trait to check if the type is in fact an ordered container.
	 * CAUTION: If you want to add another type to the trait, you might need to do it before this is included!
	 * @tparam T The container type.
	 * @param container The container itself.
	 * @return Hash value.
	 */
    template <typename T> requires is_ordered_container_v<T>
    std::size_t dice_hash(T const &container) {
        return dice_hash_ordered_container(container);
    }

    /** Implementation for unordered container.
     * It uses a custom type trait to check if the type is in fact an unordered container.
     * CAUTION: If you want to add another type to the trait, you might need to do it before this is included!
     * @tparam T The container type.
     * @param container The container itself.
     * @return Hash value.
     */
    template <typename T> requires is_unordered_container_v<T>
    std::size_t dice_hash(T const &container) {
        return dice_hash_unordered_container(container);
    }

	template<typename... Ts>
	std::size_t hash_and_combine(Ts &&...values) {
		return xxh::xxhash3<detail::size_t_bits>(std::initializer_list<std::size_t>{dice_hash(std::forward<Ts>(values))...}, seed);
	}

	template<typename Container>
	std::size_t dice_hash_ordered_container(Container const &container) {
		xxh::hash3_state_t<detail::size_t_bits> hash_state(seed);
		std::size_t item_hash;
		for (const auto &item : container) {
			item_hash = dice_hash(item);
			hash_state.update(&item_hash, sizeof(std::size_t));
		}
		return hash_state.digest();
	}

	template<typename Container>
	std::size_t dice_hash_unordered_container(Container const &container) {
		std::size_t h{};
		for (auto const &it : container) {
			h = dice_hash_invertible_combine(h, dice_hash(it));
		}
		return h;
	}


	/** Wrapper class for the dice_hash function.
	 * It is a typical hash interface.
     * @tparam T The type to define the hash for.
     */
	template<typename T>
	struct DiceHash {
	    /** Overloaded operator to calculate a hash.
	     * Simply calls the dice_hash function for the specified type.
	     * @param t The value to calculate the hash of.
	     * @return Hash value.
	     */
		std::size_t operator()(T const &t) const noexcept {
			return dice_hash(t);
		}
	};

}// namespace Dice::hash


#endif//HYPERTRIE_DICEHASH_HPP